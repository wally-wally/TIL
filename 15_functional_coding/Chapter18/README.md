# Chapter18. 반응형 아키텍처와 어니언 아키텍처

<br>

## 1. 반응형 아키텍처와 어니언 아키텍처 개요

| 아키텍처        | 내용                                                         |
| --------------- | ------------------------------------------------------------ |
| 반응형 아키텍처 | <ul><li>순차적 액션 단계에 사용하고, 코드에 나타난 순차적 액션의 순서를 뒤집는다.</li><li>효과와 그 효과에 대한 원인을 분리해서 코드에 복잡하게 꼬인 부분을 풀 수 있다.</li><li>반응형 아키텍처는 원인과 효과의 중심을 관리한다.</li></ul> |
| 어니언 아키텍처 | <ul><li>서비스의 모든 단계에서 사용하며 웹 서비스나 온도 조절 장치 같은 현실 세계와 상호작용하기 위한 서비스 구조를 만든다.</li><li>함수형 사고를 적용한다면 자연스럽게 쓸 수 있는 아키텍처이다.</li></ul> |

 <br>

## 2. 반응형 아키텍처

- 애플리케이션을 구조화하는 방법으로 핵심 원칙은 이벤트에 대한 반응으로 일어날 일을 지정하는 것이다.
- 웹 서비스와 UI에 잘 어울리는데 웹 서비스는 웹 요청 응답에 일어날 일을 지정하고, UI는 버튼 클릭과 같은 이벤트 응답에 일어날 일을 지정하면 된다.
  - 이런 것을 일반적으로 이벤트 핸들러라고 한다.
- 반응형 아키텍처는 코드에 나타난 순차적 애션의 순서를 뒤집는다.
  - X를 하고 Y 하는 대신, X가 일어나면 언제나 Y를 한다.
  - 이렇게 하면 코드를 읽기 쉽고 유지보수하기도 좋다.
- 반응형 아키텍처가 코드에 주는 중요한 영향
  - 원인과 효과가 결합되 것을 분리한다.
  - 여러 단계를 파이프라인으로 처리한다.
  - 타임라인이 유연해진다.

<br>

## 3. 반응형 아키텍처 예시

### (1) `ValueCell` -> 액션!

- `ValueCell`의 `update()` 메서드 사용시 현재 값을 항상 올바르게 유지할 수 있는 이유
  - `update()`를 사용할 때 계산을 넘기기 때문이다.
  - 계산은 현재 값을 받아 새로운 값을 리턴한다.
  - 현재 값이 도메인 상에서 올바른 값이 계산이 항상 올바른 값을 리턴한다면 이 메서드는 올바른 값으로 새로운 값을 계산하기 때문에 항상 올바른 값을 유지할 것이다.
- `ValueCell`은 <u>다른 타임라인에서 읽거나 쓰는 순서를 보장하지 않는다.</u>
  - 하지만 어떤 값이 저장되어도 <u>그 값이 항상 올바른 값이라는 것은 보장</u>한다.
- `ValueCell`을 일관되게 유지하기 위한 전제조건
  - 올바른 값으로 초기화한다.
  - `update()` 메서드에는 계산을 전달한다. (절대로 액션을 전달하지 말 것)
  - 계산은 올바른 값이 주어졌다면 올바른 값을 리턴해야한다.

```javascript
function ValueCell(initialValue) {
  var currentValue = initialValue; // 변경 불가능한 값(컬렉션이 될 수 있다)을 하나 담아 둔다.
  var watchers = []; // 감시자 목록을 저장
  return {
    val: function() { // 현재의 값을 가져온다.
      return currentValue;
    },
    update: function(f) { // 현재 값에 함수를 적용해 값을 바꾼다.(교체 패턴)
      var oldValue = currentValue;
      var newValue = f(oldValue);
      if (oldValue !== newValue) { // 값이 바뀔 때
        currentValue = newValue;
        forEach(watchers, function(watcher) { // 모든 감시자를 실행
          watcher(newValue);
        });
      }
    },
    addWatcher: function(f) { // 새로운 감시자를 추가
      watchers.push(f);
    }
  }
}
```

<br>

### (2) `FormulaCell` -> 액션!

- `FormulaCell`로 이미 있는 셀에서 파생한 셀을 만들 수 있다.
- 다른 셀의 변화가 감지되면 값을 다시 계산한다.

```javascript
function FormulaCell(upstreamCell, f) {
  var myCell = ValueCell(f(upstreamCell.val())); // ValueCell을 재사용
  upstreamCell.addWatcher(function(newUpstreamValue) { // 셀 값을 다시 계산하기 위해서 감시자를 추가
    myCell.update(function(currentValue) {
      return f(newUpstreamValue);
    });
  });
  return { // val()과 addWatcher()를 myCell에 위임
    val: myCell.val,
    addWatcher: myCdell.addWatcher, // FormulaCell 값은 직접 바꿀 수 없다.
  };
}

var shipping_cart = ValueCell({});
var cart_total = FormulaCell(shopping_cart, calc_total); // shopping_cart가 바뀔 때 cart_total도 바뀐다.
```

- `FormulaCell`은 값을 직접 바꿀 수 없다.
  - 감시하던 상위(upstream) 셀 값이 바뀌면 `FormulaCell` 값이 바뀐다.
  - 상위 셀이 바뀌면 상위 값을 가지고 셀 값을 다시 계산한다.
- `FormulaCell`에는 값을 바꾸는 기능은 없지만 `FormulaCell`을 감시할 수 있다.

<br>

## 4. 반응형 아키텍처가 주는 영향

### (1) 원인과 효과가 결합한 것을 분리한다.

- 결합의 분리는 원인과 효과의 중심을 관리한다.
- 원인이나 효과가 늘어나면 관리해야 할 것도 늘어난다.
  - 원인과 효과의 중심을 잘 관리해서 관리해야 할 것이 빠르게 늘어나지 않도록 해야 한다.
- 관리해야 할 것이 늘어나는 문제를 곱셈에서 덧셈으로 바꿀 수 있다.
  - 5개의 원인과 4개의 결과가 있기 때문에 5 X 4 대신 5 + 4로 만들 수 있다.
- 효과를 추가해도 원인을 고치지 않아도 되고, 원인을 추가해도 효과를 고치지 않아도 되기 때문에 관리해야 할 것은 하나만 늘어난다.
- 비슷한 상황으로 DOM을 갱신하는 곳에서는 DOM을 갱신하는 것만 신경 쓰면 된다.
- 주의할 점은 문제가 없는데 이 방법으로 분리하는 것은 좋지 않다.
  - 코드에 액션을 순서대로 표현하는 것이 더 명확한 경우도 있다.
  - 장바구니처럼 원인과 효과의 중심이 없다면 분리하지 않는 것이 좋다.

<br>

### (2) 여러 단계를 파이프라인으로 처리한다.

- 반응형 아키텍처도 간단한 액션과 계산을 조합해 복잡한 동작을 만들 수 있다.
  - 조합된 액션은 파이프라인과 같다.
  - 데이터가 파이프라인으로 들어가 각 단계에서 처리된다.
  - 파이프라인은 작은 액션과 계산을 조합한 하나의 액션이라고 볼 수 있다.
- 어떤 일이 발생하는 여러 단계가 있다면 파이프라인으로 처리하는 것이 좋다.
  - 각 단계에서 생성된 데이터는 다음 단계의 입력값으로 사용될 것이다.
- 자바스크립트의 `Promise` 패턴, `RxJS` 등 여러 가지 구현체가 있다.
- 만약 여러 단계가 있지만 <u>데이터를 전달하지 않는다면 이 패턴을 사용하지 않는 것이 좋다.</u>
  - 데이터를 전달하지 않으면 파이프라인이라고 볼 수 없다.
  - 따라서 올바른 반응형 아키텍처가 될 수 없다.

<br>

### (3) 타임라인이 유연해진다

- 순서를 정의하는 방법을 뒤집기 때문에 자연스럽게 타임라인이 작은 부분으로 분리된다.
- 기존에 짧은 타임라인이 좋은 것이라고 했지만 타임라인이 많아지는 것도 좋지 않다.
  - 하지만 타임라인이 많아도 문제가 없는 경우가 있다.
  - 공유하는 자원이 없으면 타임라인이 많아져도 문제가 없다.

<br>

## 5. 어니언 아키텍처

(작성중...)
